## REST_AUTOMATE

A Test Framework for Rest API Automation.

The framework is built on Java, TestNG and Maven powered with external libraries such as Extent, Allure for reporting, Jenkins for achieving Continuous Integration.

### 1.0 FRAMEWORK SKELETON

The project is created as a maven project with the below structure.
           
![alt text ](src/main/java/Images/1.png) 

Below sections describe the framework components.

#### 1.1 src/main/java

src/main/java folder holds **com** (application specific files) package and a **generic** package.

**com** package has two example applications (github and twitter) in which the application specific files are maintained as **assets** and **corefunctions**.

![alt text ](src/main/java/Images/srcmainjavacom.png)

**assets** contains the **data** (xls) files, request and response pojo files (in **model**) and importantly **resources**. 
**resources** has the endpoints defined under **Path** file, commonly used headers in **RequestHeaders** file and a **Specification** file for building the Request ad Response specifications.  
**corefunctions** contains the methods used frequently in the test cases.                                                                                                                          
**generic** package constitutes the backbone of the project. The generic methods which can be used across any project (github, twitter) are maintained here.
Below is the overview of the various components in generic package which will be used for the test cases implementation.

    Files in the generic package should not be edited as this is the foundation of the framework and changes to its files will impact the smooth working of the framework.

![alt text ](src/main/java/Images/srcmainjavageneric.png) 

| Package Name | Description |
| ------ | ------ |
| authentication | authentication methods (basic, oauth1, oauth2) |
| config | ConfigPropertyReader for reading the property files |
| listeners| listener methods for retry and reporting operations |
| rest | rest api methods for different http verbs GET, POST, DELETE etc |
| statuscode| commonly used http status codes |
| utils | common utilities for excel (read/ write) operation, DB operations, Reports |

#### 1.2 src/main/resources

![alt text ](src/main/java/Images/srcmainres.png) 

| Property file | Description |
| ------ | ------ |
| allure.properties | Defines the path to Allure report generation  |
| config.properties | Application auth credentials, DB properties, Path to Extent report generation |
| log4j.properties | Config details of logger - log level, layouts, etc |

#### 1.3 src/test/java

![alt text ](src/main/java/Images/srctestjava.png) 

**com** package inside src/test/java contain the test cases (example: github, twitter).
The sample test cases cover the aspects of making the DB connections, logging, reporting with testNG.

#### 1.4 src/test/logs

console.log prints out the logs of the running tests.

#### 1.5 src/test/Reports

At runtime, JSON files for reporting are created in Reports folder. These json files are internally used by Allure to build the dashboards.

Allure reports can be viewed at http://qacentral.pramati.com:8080/job/YOUR_JOB_NAME/allure/

Extent reports can be viewed at http://qacentral.pramati.com:8080/job/YOUR_JOB_NAME/ExtentReport/

#### 1.6 POM.xml

Dependencies in the framework are defined in POM.xml.

![alt text ](src/main/java/Images/dependencies.png) 


#### 1.7 TestNG.xml File

Github_TestNG.xml,Twitter_TestNG.xml - This xml file is a testNg suite configuration file that contains information on which test cases are to be run, its parameters etc.

### 2.0 Reports

#### 2.1 Extent Reports

Extent Report creates interactive and detailed report for our tests. Listeners are interfaces that "listen" to a specified event. By implementing listener concept in Extent reports, the reports are further customized to log the below events in Extent Reports.  

    onStart
    onFinish
    onTestStart
    onTestSuccess
    onTestFailure
    onTestSkipped
    onTestFailedButWithinSuccessPercentage

This implementation of ITestListener can be found in path \src\main\java\generic\listeners\TestListener.java. 

Then, listener class is added to the testNg.xml file. 

![alt text ](src/main/java/Images/listeners.png) 

Extent Reports gets generated by running the testNg.xml file.

#### 2.2 Allure Reports

Unlike extent reports, Allure doesn’t need to be explicitly mentioned in listeners to get triggered. When you run a test case it is automatically picked up by allure.
Setup: 
* Add allure dependency in Pom.xml

![alt text ](src/main/java/Images/allure_dependency.png) 

###### How to view Allure reports in local machine:

* To generate a report, install Allure command-line interpreter.
* Download the latest version as a zip archive from the link (https://bintray.com/qameta/generic/allure2).
* Unpack the archive to allure-commandline directory.
* Navigate to bin directory.
* Add allure to system PATH.

![alt text ](src/main/java/Images/allure.png) 

* Open command prompt and navigate to the project directory
* Type the below command
    **allure serve allure-results**
* This opens the allure results in the browser.

 
H.Sample Workflow for GitHub API
Let’s take a sample test case and work through it.
Class GitRepositoryScenarios.java in path src\test\java\com\github\GitRepositoryScenarios.java


### 3.0 What is a POJO class and how is it useful for json body validation?

Plain Old Java Object (POJO) is used to describe a class that doesn't need to be a subclass of anything, or implement specific interfaces, or follow a specific pattern.

In our case, we create POJO classes for request and response JSON, which is then used in the test cases. This prevents the extraction of json body every time for test verification and uses the generated POJO for comparing the actual and expected results.

Consider a sample response json :

![alt text ](src/main/java/Images/pojo1.png) 

The POJO can be created as follows:

![alt text ](src/main/java/Images/pojo2.png)

Create a java class for response body. Add the variables from response as private variable in this Pojo class. Create getters and setters for these variables. If variable name is foo, its getter would be public String getFoo and setter would be setFoo. The convention is that you add “get” and “set” to the variable.
If you want to POST something you use **pojoclass.setFoo(“abc”)**.
The object of this class is passed through api.

Let’s look at the POJO CreateAndModifyRepository.class from the project.
 Path:\src\main\java\com\github\assets\model\CreateAndModifyRepository.java
In order to send a json body as request for create repository function we create a POJO class of that request body as shown below:

![alt text ](src/main/java/Images/pojo3.png)

In the function create an object of the above class as shown below and set the values:


![alt text ](src/main/java/Images/pojo4.png)

Similarly we can create a POJO for response body as well. The syntax would be 

    ResponsePOJO responsepojo = responseobjectname.as(responsePOJO.class)

![alt text ](src/main/java/Images/pojo5.png)

http://www.jsonschema2pojo.org/ - This link can be used to generate POJO class as well. The input will the json body and it will automatically generate the POJO for you.

### 4.0 Lombok

Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again, with one annotation your class has a fully featured builder.

Adding Lombok is simple. Just add the below dependency in your maven project pom.xml file.

![alt text ](src/main/java/Images/lombokdependency.png)

To check the Lombok plugin enabled in our intellij Editor.

![alt text ](src/main/java/Images/lombokplugin.png)

And Make Sure the Annotation also enabled.

![alt text ](src/main/java/Images/lombokannotation.png)


 
### 5.0 Sample Workflow for GitHub API

Let’s take a sample test case and work through it.
Class GitRepositoryScenarios.java in path src\test\java\com\github\GitRepositoryScenarios.java

![alt text ](src/main/java/Images/sampleworkflow1.png)

In beforeClass , basic auth is called. This takes care of authentication.

![alt text ](src/main/java/Images/sampleworkflow2.png)

If you take a closer look at auth function, we read the credentials from config file and sets the authentication in place. Now, we can proceed to write a simple repository creation and deletion scenario.

![alt text ](src/main/java/Images/sampleworkflow3.png)

Here, class RepositoryMethods have basic and the most commonly used functions from Github scenarios. We pass necessary headers and verify the status code. We also verify the body of the response using POJO classes created.  


### 6.0 Continuous Integration

Jenkins in used as the Continuous Integration tool. Jenkins is hosted in a Server and can be accessed using the below link.

http://qacentral.pramati.com:8080

**Setting up Rest Automate framework with CI**

1. Go to https://gitlab.pramati.com/qa_framework_team/RestAutomate and fork the project.

2. Go to your forked repository and copy the URL in "Clone with HTTPS". We need to pass this as a parameter (**GITLAB_REPO_URL**) in Jenkins job as given in 5th step.

   ex. https://gitlab.pramati.com/suganthia/RestAutomate.git
   
3. Create an jenkins account using the link http://qacentral.pramati.com:8080/signup

4. Go to link http://qacentral.pramati.com:8080/job/jen/pipeline-syntax/ and create the pipeline script as given below

    a. Sample Step : git:Git (Choose this from dropdown)
    
    b. Repository URL : https://gitlab.pramati.com/suganthia/RestAutomate.git (Give your forked repository)
    
    c. Branch : master (Should be master by default)
    
    d. Credentials : Click on Add -> Jenkins      
       "Jenkins Credentials Provider: Jenkins" pop up appears. 
       Type your Username and Password (Use gitlab credentials). Without modifying other fields, Click Add.
       
    e.  Choose the added credentials from Credentials dropdown.
    
    f. Click on "Generate Pipeline Script".   
       credentialsId would be used as a parameter in **USER_CREDENTIALS** in Jenkins job as given in 5th step.
        
![alt text ](src/main/java/Images/snippet_generator.png)

5. Copy the following job. Give a unique name. Click ok.    
   http://qacentral.pramati.com:8080/job/Jenkins_Pipeline/

6. Now we will be taken to configure page of the newly created job. 

   Change the default values for MAIL_RECIPIENTS (give the email ids of the persons to be notified), GITLAB_REPO_URL (refer step 2) and USER_CREDENTIALS (refer step 4.f).
   
7. In the same configure page of the job, in the **Build Triggers** section, make sure the below option is enabled for Push Events. 

   Build when a change is pushed to GitLab. GitLab webhook URL: http://qacentral.pramati.com:8080/project/YOUR-JOB-NAME
   
![alt text ](src/main/java/Images/BuildTriggers_webhook.png)   


8. Copy the GitLab webhook URL (http://qacentral.pramati.com:8080/project/YOUR-JOB-NAME) and go to your forked repository in Gitlab.
   In Settings -> Integrations, Give the URL and Save Changes. (You have the option to test the hook)

   Now we have the CI ready for your project. Whenever you push changes to your project, Jenkins gets notified and starts executing your Test job. Upon completion of the job execution, you have the reports (Allure and extent reports) generated and you get an email notification with all details. 
   
       Sit back and enjoy !!!



    
### FAQ 

* I have a set of Rest APIs to automate. How do I adopt this framework for automation?

Get the API details - Base URL, Auth credentials, HTTP Method, Endpoints, Path parameters, Query parameters, Request Header information, Request and Response JSON

Using the github sample (src\main\java\com\github) modify the below files

    * Place the Base URL & Auth credentials in src\main\resources\config.properties 
    * Place the Endpoints in src\main\java\com\github\assets\resources\Path.java
    * Place the Request Header details in src\main\java\com\github\assets\resources\RequestHeaders.java
    * Place the pojo files in src\main\java\com\github\assets\model
    * Create the frequently used methods in src\main\java\com\github\corefunctions using the rest.Api methods (postData, getData, deleteData, patchData, putData)
    * Start writing the tests in test folder. Create the request payload using the pojo files and make response verification again through the pojo files.
